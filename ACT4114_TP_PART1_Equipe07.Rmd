---
output:
  pdf_document:
    includes:
      before_body: TP-title.tex
      in_header: preamble-latex.tex
---  
\centering  

\clearpage  

\tableofcontents   

\justify  
\clearpage  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r paquetages, message=FALSE, eval=TRUE, include=FALSE, echo = FALSE}
### Liste des paquetages
liste.paquetage <- c("ggplot2", "CASdatasets", "mice", "stringi")
### On installe les paquetages de la liste qu'on a pas déjà
inst <- liste.paquetage %in% installed.packages()
if(length(liste.paquetage[!inst]) > 0) install.packages(liste.paquetage[!inst])
lapply(liste.paquetage, require, character.only = TRUE)

options(scipen=999)
```

# Introduction

Pour ce travail, l'objectif est de construire un modèle de prime pure pour la somme des réclamations en assurance automobile (tous types confondus). La base de données utilisé est. #####. 
##### Il faut faire la citation
##### 
#####
Sa structure est très intuitive. En bref, chaque assuré est associé à une ligne. Chacune des lignes renferme l'ensemble des informations connues sur l'assuré et sur les montants de réclamations dont il est responsable en date de la production du jeu de données. Puisque les mêmes informations sont demandées pour chaque client, les lignes sont divisées en colonne homogènes, ce qui nous permet de faire une analyse efficace du comportement des données. En tout, chaque ligne comporte 23 variables, dont 5 variables décrivant les montants de réclamations, chacune étant associée à un type de dommage spécifique (par exemple une collision ou un vol de la voiture). Nous avons choisi de nous intéresser au montant total des réclamations pour un client et c'est donc la somme des 5 types de réclamations possibles qui sera notre variable réponse. Notre modèle utilisera les informations collectés par l'assureur pour établir une prédiction de l'ensemble des coûts de réclamations que le client engendrera pour une exposition unitaire. 
####
#### Définition de l'exposition
####
####


\clearpage  


```{r donnees, include=FALSE, echo = FALSE}
data(brvehins1a)
Veh <- brvehins1a

Veh$ClaimNb <- Veh$ClaimNbRob + Veh$ClaimNbPartColl + Veh$ClaimNbTotColl + Veh$ClaimNbFire + Veh$ClaimNbOther

Veh$ClaimAmount <- Veh$ClaimAmountRob + Veh$ClaimAmountPartColl + Veh$ClaimAmountTotColl + Veh$ClaimAmountFire + Veh$ClaimAmountOther
Veh$ExposTotal[Veh$ExposTotal == 0] <- NA # Ajustement pour mettre exposition de 0 comme NA
Veh$TotClaimExpUnit <- Veh$ClaimAmount/Veh$ExposTotal

# Ajustement des niveaux
levels(Veh$DrivAge) <- levels(Veh$DrivAge)[c(2, 3, 4, 5, 1)]
```

# Création d'une nouvelle variable explicative

```{r ExprReg, message=FALSE, echo = FALSE, warning = FALSE}
Veh$VehManuf <- gsub('.{2}$', '', stri_extract(Veh$VehModel, regex="^([a-zA-Z]|[0-9]|[-]|[ ])* -"))
Veh$VehManuf[Veh$VehModel == "Outros"] <- "Other"
Veh$VehManuf <- as.factor(Veh$VehManuf)
lvl <- levels(Veh$VehManuf)
lvl[which(table(Veh$VehManuf) < 100)] <- "Other"
levels(Veh$VehManuf) <- lvl
```

\clearpage

# Analyse Exploratoire

## Nettoyage des données

Avant de lancer le développement de notre modèle, quelques ajustements sont recquis. Notamment, les variables «State» et «StateAb» représentent la même information, l'une étant simplement l'abbréviation de l'autre. Nous allons seulement conserver la variable «State».

Également, une des observations a une année de véhicule de 0, ce qui est clairement impossible, donc on remplace le 0 par un **NA**.

```{r cleanup, message=FALSE, echo = FALSE}
Veh <- Veh[-8]

Veh$VehYear[Veh$VehYear < 1900 | is.na(Veh$VehYear)] <- NA
```

```{r data, message=FALSE, echo = FALSE}
## Création d'une nouvelle base de donnée pour l'analyse exploratoire
VehClaimOnly <- Veh[Veh$TotClaimExpUnit > 0, ]
VehClaimOnly$LogClaim <- log(VehClaimOnly$TotClaimExpUnit)
```

\clearpage


## Somme des réclamations

La somme des réclamations associées à chaque assuré est la variable réponse pour ce projet. Cette variable prend fréquemment la valeur de 0, soit `r sum(na.omit(Veh$ClaimAmount == 0))` fois sur `r sum(!is.na(Veh$ClaimAmount))`. Cela revient à dire qu'un assuré ne fera pas de réclamation `r round(sum(na.omit(Veh$ClaimAmount == 0))/sum(!is.na(Veh$ClaimAmount)), 3)*100`% du temps. 

\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|c| } 
 \hline
 Moyenne & Médiane & Écart-type & Minimum & Maximum \\ 
 \hline
 `r round(mean(na.omit(Veh$ClaimAmount)), 1)` & `r round(median(na.omit(Veh$ClaimAmount)), 1)` & `r round(sd(na.omit(Veh$ClaimAmount)), 1)` & `r round(min(na.omit(Veh$ClaimAmount)), 1)` & `r round(max(na.omit(Veh$ClaimAmount)), 1)` \\ 
 \hline
\end{tabular}
\end{center}

Puisqu'un montant de réclamation peut prendre des valeurs assez élevées, les graphiques peuvent devenir plutôt difficiles à lire. Pour remédier à ce problème, le logarithme naturel du montant total des réclamations est utilisé dans les graphiques. Cela a cependant un coût : toutes les réclamations de 0 doivent être retirées du jeu de données. Des informations supplémentaires par rapport à ces réclamations seront ajoutées au long de l'analyse exploratoire pour pallier ce défaut.


```{r HistClaim, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:HistRecl}Histogramme du logarithme des montants de réclamation"}
ggplot(VehClaimOnly, aes(x=LogClaim))+
  geom_histogram() +
  xlab("Logarithme des réclamations") +
  ylab("Nombre de réclamations")
```

Comme on peut voir dans la Figure \ref{fig:HistRecl}, la distribution est quelque peu asymétrique et la queue est très lourde. En effet, on observe une fréquence somme toute élevée de réclamations très importante. Il n'est pas rare que le logarithme naturel du montant de réclamations atteigne 10 et même plus, alors que la médiane est plutôt autour de 6.

\clearpage

## Exposition

Le minimum est de 1/365, soit d'une journée. Il semble y avoir beaucoup d'annulations de même que des clients particulièrement fidèles puisque la médiane d'exposition est de moins d'un an tandis que la moyenne est de plus de 3 ans.

\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|c| } 
 \hline
 Moyenne & Médiane & Écart-type & Minimum & Maximum \\ 
 \hline
 `r mean(na.omit(Veh$ExposTotal))` & `r median(na.omit(Veh$ExposTotal))` & `r sd(na.omit(Veh$ExposTotal))` & `r min(na.omit(Veh$ExposTotal))` & `r max(na.omit(Veh$ExposTotal))` \\ 
 \hline
\end{tabular}
\end{center}

```{r PointsExposition, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointExpos}Logarithme des réclamations en fonction de l'exposition"}
ggplot(VehClaimOnly, aes(x=ExposTotal, y=LogClaim)) + 
  geom_point(alpha = 0.3) +
  ylab("Logarithme des réclamations")
```

\clearpage 

## Genre

La variable **Gender** a quatre niveaux : *Male*, *Female*, *Corporate* et *NA*.

\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
 \hline
  & Male & Female & Corporate & NA \\ 
 \hline
 Fréquence & `r sum(na.omit(Veh$Gender) == "Male")` & `r sum(na.omit(Veh$Gender) == "Female")` & `r sum(na.omit(Veh$Gender) == "Corporate")` & `r sum(is.na(Veh$Gender))` \\ 
 \hline
\end{tabular}
\end{center}

En analysant le lien avec les réclamations, on remarque qu'il n'y a absolument aucune réclamation pour le genre *Corporate*. Étant donné la très grande exposition qui y est associée, c'est évidemment absurde et on en déduit que l'assureur demande l'information sur le conducteur lorsqu'un accident survient et qu'une réclamation est nécessaire. Ainsi, il ajoute l'information rétrospectivement et il sera donc possiblement nécessaire de régrouper le genre *Corporate* avec les clients pour lesquels l'information sur le genre est inconnue. 

\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
 \hline
  & Male & Female & Corporate & NA \\ 
 \hline
 Aucune réclamation & `r sum(na.omit(Veh$ClaimAmount[Veh$Gender == "Male"] == 0))` & `r sum(na.omit(Veh$ClaimAmount[Veh$Gender == "Female"]) == 0)` & `r sum(na.omit(Veh$ClaimAmount[Veh$Gender == "Corporate"]) == 0)` & `r sum(na.omit(Veh$ClaimAmount[is.na(Veh$Gender)] == 0))` \\ 
 \hline
\end{tabular}
\end{center}


```{r BoxplotGender, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BPGen}Logarithme des réclamations par genre"}
ggplot(VehClaimOnly, aes(x=Gender, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations")
```

En terme de sévérité, les moyennes des réclamations ne semblent pas changer d'un genre à un autre, mais il est possible d'observer à la Figure \ref{fig:BPGen} des réclamations plus élevées en moyenne lorsque le genre est inconnu. Il faut admettre que c'est plutôt surprenant de prime abord. Il convient de noter que c'est l'échantillon le plus faible des trois catégories, mais avec plus de 10 000 réclamations, il est difficile de blâmer le hasard. Une analyse du patron de non-réponse inclaunt les autres variables s'impose.

\clearpage 

## Âge du conducteur

La variable de l'âge du conducteur n'est pas continue, mais plutôt divisée en 5 groupes. La fréquence de chaque niveau est illustrée ci-dessous :

\begin{center}
\begin{tabular}{ |c|c|c|c|c|c| } 
 \hline
  & 18-25 & 26-35 & 36-45 & 46-55 & >55 \\ 
 \hline
 Fréquence & `r sum(na.omit(Veh$DrivAge) == "18-25")` & `r sum(na.omit(Veh$DrivAge) == "26-35")` & `r sum(na.omit(Veh$DrivAge) == "36-45")` & `r sum(na.omit(Veh$DrivAge) == "46-55")` & `r sum(na.omit(Veh$DrivAge) == ">55")` \\ 
 \hline
\end{tabular}
\end{center}

À la Figure \ref{fig:BPDrivAge}, il est possible d'observer que la tranche d'âge 26-35 ans a, en moyenne, les réclamations les plus élevées. Cela est plutôt intuitif car les jeunes conducteurs sont reconnus pour être plus téméraires et ainsi causer plus d'accidents. Une hypothèse vraisemblable pour expliquer que le groupe de conducteurs de 18 à 25 ans n'a pas des réclamations plus élevées est qu'ils n'ont tout simplement pas les moyens de se procurer des véhicules de grande valeur. 

Encore une fois, lorsque l'information est manquante, les réclamations sont bien plus élevées en moyenne.

```{r BoxplotAge, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BPDrivAge}Logarithme des réclamations par Âge de conducteur"}
ggplot(VehClaimOnly, aes(x=DrivAge, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations") + 
  xlab("Groupes d'âge")
```

\clearpage 

## Année du véhicule

```{r PointsAgeVeh, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointVehYear}Logarithme des réclamations en fonction de l'année du véhicule"}
ggplot(VehClaimOnly, aes(x=VehYear, y=LogClaim)) + 
  geom_point(alpha = 0.3) +
  ylab("Logarithme des réclamations") +
  geom_smooth()
```


\clearpage 

## Modèle du véhicule

```{r, message=FALSE, echo = FALSE, warning = FALSE}
VehManufGraph <- VehClaimOnly$VehManuf
lvl2 <- levels(VehClaimOnly$VehManuf)
lvl2[which(table(VehClaimOnly$VehManuf) < 500)] <- "Other"
levels(VehManufGraph) <- lvl2
```


```{r BoxplotManuf, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BoxPlotArea}Logarithme des réclamations par région"}
ggplot(VehClaimOnly, aes(x=VehManufGraph, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations") +
  coord_flip()
```
Le graphique ci-haut présente la distribution du logarithme des réclamations selon les principales marques de véhicules présentes dans le jeu de données. Sans surprise, les véhicules les plus luxueux comme *Mercedes-Benz* sont titulaires des réclamations les plus importantes en moyenne. Cependant, comme cette base de donnée n'origine pas du Québec, il est important de rappeler qu'une partie non négligeable des réclamations sert à payer les dommages corporels de même que les dommage matériels à autrui. Donc même si l'assuré possède un véhicule plus abordable comme une *Kia*, on observe quand même quelques réclamations très substantielles. 
Enfin, conformément aux variables précédentes, les réclamations sont significativement plus couteûses en moyenne lorsque la marque du véhicule est inconnue.

\clearpage 

## Area

```{r ModifArea, message=FALSE, echo = FALSE, warning = FALSE}
AreaGraph <- VehClaimOnly$Area
lvl3 <- levels(VehClaimOnly$Area)
lvl3[which(table(VehClaimOnly$Area) < 2000)] <- "Other"
levels(AreaGraph) <- lvl3
```

```{r BoxplotArea, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BoxPlotArea}Logarithme des réclamations par région"}
ggplot(VehClaimOnly, aes(x=AreaGraph, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations") +
  coord_flip()
```

Similairement, voici les réclamations dans les régions les plus récurrentes de la base de données. Sans surprise, les réclamations varient beaucoup même au sein d'une même région et il est difficile d'établir des constats en lesquels l'analyste avisé pourrait réellement avoir confiance. 

\clearpage

## State

```{r ModifState, message=FALSE, echo = FALSE, warning = FALSE}
StateGraph <- VehClaimOnly$State
lvl4 <- levels(VehClaimOnly$State)
lvl4[which(table(VehClaimOnly$State) < 2000)] <- "Other"
levels(StateGraph) <- lvl4
```

```{r BoxplotState, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BoxPlotState}Logarithme des réclamations par état"}
ggplot(VehClaimOnly, aes(x=StateGraph, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations") +
  coord_flip()
```

Un constat similaire est de mise quant au lien entre la ville (ou région administrative selon le cas) et les réclamations. S'il est vrai qu'en moyenne les réclamations sont plus faibles dans la ville Rio de Janeiro qui a assurément la réputation d'accueillir une population moins aisée que Santa Catarina par exemple, il n'en demeure pas moins que cela varie énormément et des extrèmes sont observés dans toutes les villes du graphique et il est difficile, de prime abord, de ne pas attribuer les écarts au simple hasard. 

\clearpage


## Prime Totale

La prime totale est une variable qui reflète la somme totale de primes pour une combinaison véhicule-assuré donnée. Afin de mieux comprendre la distribution de cette variable, plusieurs analyses peuvent être effectuées:

```{r PointsPrimeHist, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointPremHist}Logarithme des réclamations en fonction de la prime totale"}
ggplot(VehClaimOnly, aes(x=log(PremTotal)))+
    geom_histogram()
```

Tout d'abord, l'histogramme révèle que la distribution des primes totales présente une asymétrie négative, avec un nombre plus important de primes de faible montant par rapport à celles de montant élevé.

```{r PointsPrime, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointPrem}Logarithme des réclamations en fonction de la prime totale"}
ggplot(VehClaimOnly, aes(x=log(PremTotal), y=LogClaim)) + 
  geom_point(alpha = 0.3) +
  ylab("Logarithme des réclamations")
```
La prime totale présente clairement la meilleure puissance prédictive, mais elle ne peut être utilisée pour le modèle. Effectivement, il va sans dire que le but de notre projet est de développer notre propre modèle de calcul de la prime. Il est important de garder à l'esprit que la prime est assurément calculée à partir des variables présentées plus haut, en soi, elle n'apporte donc aucune nouvelle information puisqu'elle est elle même une combiaison de toutes les autres variables. Ainsi, il serait contre-productif de tenter de réutiliser la prime dans notre modèle.  On remarque que les primes plus basses sont associées à une plus grande variance dans les montants de réclamations. Cela correspond bien aux attentes, un modèle typique devrait être plus performant pour prédire les réclamations des gros risques, c'est à dire, ceux qui ont une grande mesure d'exposition et des dimensions risquées.

\clearpage

## SumInsAvg

Cette variable correspond au montant moyen assuré aggrégé au grain de la table, et représente la limite supérieure des réclamations possibles. On peut explorer cet hypothèse avec le graphique suivant:

```{r PreuveIns, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointSumInsAvg}Logarithme des réclamations en fonction de SumInsAvg"}
library(gridExtra)
ggplot(VehClaimOnly,aes(x=ClaimAmount/ClaimNb, y=SumInsAvg, col = ClaimAmount/ClaimNb < SumInsAvg))+
    geom_point(alpha=0.4)+
    stat_function(fun=function(x) x)
```

On voit donc que dans la très grande majorité des cas, le montant assuré moyen est supérieure au montant réclamé par réclamation. On peut croire que les points sous la courbe représente des observations où le montant a assuré diminué au cours de la période assuré. En effet, Si le montant assuré a été plus élevé à un moment et a diminué subitement, il est possible que la mesure de sévérité moyenne soit plus élevé que le montant d'assurance moyen.


```{r PointsInsAvg, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointSumInsAvg}Logarithme des réclamations en fonction de SumInsAvg"}
ggplot(VehClaimOnly, aes(x=SumInsAvg, y=LogClaim)) + 
  geom_point(alpha = 0.3) +
  ylab("Logarithme des réclamations")+
    geom_smooth()
```



\clearpage

# Traitement des valeurs manquantes

## Visualisation

Visualisons les données manquantes.

```{r MissingDataVis, message=FALSE, echo=FALSE, warning=FALSE, results='hide', fig.keep='all', fig.cap="\\label{fig:MissingDataVis}Visualisation des données manquantes"}
md.pattern(Veh[, colSums(is.na(Veh)) != 0], rotate.names = T)
```
Dans la figure \ref{fig:MissingDataVis}, les variables n'ayant pas d'observations manquantes n'ont pas été affichées afin de simplifer le diagramme. Au total, `r round(sum(rowSums(is.na(Veh)) != 0) / nrow(Veh) * 100, 2)`% des rangées ont au moins une variable manquante.


On remarque que lorsque la variable «Area» est inconnue, la variable «State» l'est aussi. Puisqu'il y a  seulement `r sum(is.na(Veh$Area) & is.na(Veh$State))` observations manquantes pour ces deux variables, nous les retirons du jeu de données.
```{r, message=FALSE, echo=FALSE}
Veh <- Veh[!is.na(Veh$Area) & !is.na(Veh$State),]
```

Il y a seulement une observation avec une donnée manquante pour la variable «VehYear». En raison de la faible importance de cette observation vis à vis la grande taille du jeu de donnée, nous la retirons également du jeu de données.
```{r, message=FALSE, echo=FALSE}
Veh <- Veh[!is.na(Veh$VehYear),]
```

Lorsque «VehModel» est manquante, «VehGroup» et «VehManuf» le sont également. Cela est tout à fait attendu, car il n'est pas possible de classifier un véhicule si son modèle n'est pas connu et la variable «VehManuf» est créée à partir de la variable «VehModel». On teste l'hypothèse que la variable «VehModel» est MCAR avec des tests du khi-carré de Pearson.

```{r, message=FALSE}
manq <- is.na(Veh$VehModel)
chisq.test(Veh$Gender, manq, correct = F)
chisq.test(Veh$DrivAge, manq, correct = F)
chisq.test(Veh$State, manq, correct = F)
chisq.test(Veh$VehYear, manq, correct = F)
```
Toutes les *p-values* approchent de 0, on rejette l'hypothèse nulle. Le patron de non-réponse de la variable «VehModel» n'est pas MCAR. Les conclusions de ce test sont identiques pour les variables «VehGroup» et «VehManuf».

```{r, message=FALSE, echo=FALSE, results='hide'}
manq <- is.na(Veh$VehGroup)
chisq.test(Veh$Gender, manq, correct = F)
chisq.test(Veh$DrivAge, manq, correct = F)
chisq.test(Veh$State, manq, correct = F)
chisq.test(Veh$VehYear, manq, correct = F)
```
```{r, message=FALSE, echo=FALSE, results='hide'}
manq <- is.na(Veh$VehManuf)
chisq.test(Veh$Gender, manq, correct = F)
chisq.test(Veh$DrivAge, manq, correct = F)
chisq.test(Veh$State, manq, correct = F)
chisq.test(Veh$VehYear, manq, correct = F)
```

La variable «DrivAge» est la plus absente du jeu de données; elle est manquante dans `r round(sum(is.na(Veh$DrivAge)) / nrow(Veh) * 100, 2)`% des observations. Faisons un diagramme boxplot pour voir s'il y a un lien entre la présence d'une observation manquante pour cette variable et le montant des réclamations.

```{r, DrivAgelinkwithClaims, message=FALSE, echo=FALSE, warning=FALSE, results='hide', fig.keep='all', fig.cap="\\label{fig:DrivAgelinkwithClaims}Lien entre le patron de non-réponse de la variable «DrivAge» et le logarithme des réclamations"}
manq <- is.na(VehClaimOnly$DrivAge)
ggplot(VehClaimOnly, aes(x = manq, y = log(ClaimAmount))) +
  geom_boxplot() +
  ylab("Logarithme des réclamations") +
  xlab("Patron de non-réponse de «DrivAge»")
```
Il semble peu probable que les données manquantes de «DrivAge» soient MCAR. Effectivement, les tests du khi-carré de Pearson rejettent l'hyopthèse nulle que le Patron de non-réponse de cette variable est MCAR. Il ne sera pas possible d'utiliser l'approche des cas complets, donc une méthode d'imputation stochastique sera privilégié. Puisqu'il n'y a pas de test pour savoir si les données manquantes sont MAR ou NMAR, il est possible qu'un biais reste présent dans les données après l'imputation.
```{r, message=FALSE}
manq <- is.na(Veh$DrivAge)
chisq.test(Veh$Gender, manq, correct = F)
chisq.test(Veh$VehManuf, manq, correct = F)
chisq.test(Veh$State, manq, correct = F)
chisq.test(Veh$Area, manq, correct = F)
chisq.test(Veh$ClaimAmount, manq, correct = F)
```


La variable «Gender» est rarement absente toute seule. Dans la majorité des observations où cette variable est absente, «DrivAge» l'est également. Cela devra être pris en considération s'il est nécessaire d'imputer les données manquantes. Testons l'hypothèse nulle que le patron de non-réponse de la variable «Gender» est MCAR.
```{r, message=FALSE}
manq <- is.na(Veh$Gender)
chisq.test(Veh$DrivAge, manq, correct = F)
chisq.test(Veh$VehManuf, manq, correct = F)
chisq.test(Veh$State, manq, correct = F)
chisq.test(Veh$Area, manq, correct = F)
chisq.test(Veh$VehYear, manq, correct = F)
```
Une fois de plus, l'hypothèse nulle est rejetée : les observations manquantes de la variable «Gender» ne sont pas MCAR.  


Dans SumInsAvg remplacer les 0 par NA et traiter.

## Imputation des données manquantes
```{r}
Vehtest <- Veh[sample(nrow(Veh), 100), ]
Vehtest <- Vehtest[-c(4, 5, 8, 25)]
vehimp <- mice(Vehtest, m=1)
vehcomp <- complete(vehimp)
```


\clearpage

# Conclusion
