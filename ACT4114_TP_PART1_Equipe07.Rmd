---
output:
  pdf_document:
    includes:
      before_body: TP-title.tex
      in_header: preamble-latex.tex
---  
\centering  

\clearpage  

\tableofcontents   

\justify  
\clearpage  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r paquetages, message=FALSE, eval=TRUE, include=FALSE, echo = FALSE}
### Liste des paquetages
liste.paquetage <- c("ggplot2", "CASdatasets", "mice", "stringi")
### On installe les paquetages de la liste qu'on a pas déjà
inst <- liste.paquetage %in% installed.packages()
if(length(liste.paquetage[!inst]) > 0) install.packages(liste.paquetage[!inst])
lapply(liste.paquetage, require, character.only = TRUE)
```

# Introduction

Pour ce travail, l'objectif est de construire un modèle de prime pure pour la somme des réclamations (tous types confondus). 

\clearpage  

# Création d'une nouvelle variable explicative

```{r donnees, include=FALSE, echo = FALSE}

data(brvehins1a)
Veh <- brvehins1a

Veh$ClaimNb <- Veh$ClaimNbRob + Veh$ClaimNbPartColl + Veh$ClaimNbTotColl + Veh$ClaimNbFire + Veh$ClaimNbOther
Veh$ClaimAmount <- (Veh$ClaimAmountRob + Veh$ClaimAmountPartColl + Veh$ClaimAmountTotColl + Veh$ClaimAmountFire + Veh$ClaimAmountOther)/Veh$ExposTotal

# Ajustement des niveaux
levels(Veh$DrivAge) <- levels(Veh$DrivAge)[c(2, 3, 4, 5, 1)]

```

```{r ExprReg, message=FALSE, echo = FALSE, warning = FALSE}

Veh$VehManuf <- gsub('.{2}$', '', stri_extract(Veh$VehModel, regex="^([a-zA-Z]|[0-9]|[-]|[ ])* -"))
Veh$VehManuf[Veh$VehModel == "Outros"] <- "Other"
Veh$VehManuf <- as.factor(Veh$VehManuf)
lvl <- levels(Veh$VehManuf)
lvl[which(table(Veh$VehManuf) < 100)] <- "Other"
levels(Veh$VehManuf) <- lvl

```

# Analyse Exploratoire

## Nettoyage des données

Les variables «State» et «StateAb» représentent la même information, l'une étant simplement l'abbréviation de l'autre. Nous allons seulement conserver la variable «State».

```{r cleanup, message=FALSE, echo = FALSE}

Veh <- Veh[Veh$VehYear > 1900,]
Veh <- Veh[-8] #retirer StateAb du jeu de données
```

```{r data, message=FALSE, echo = FALSE}

## Création d'une nouvelle base de donnée pour l'analyse exploratoire
VehClaimOnly <- Veh[Veh$ClaimAmount > 0 & Veh$ClaimAmount < 99999999999, ]
VehClaimOnly$LogClaim <- log(VehClaimOnly$ClaimAmount)
```

## Somme des réclamations

La somme des réclamations est la variable réponse pour ce projet. Cette variable prend fréquemment la valeur de 0, soit `r sum(na.omit(Veh$ClaimAmount == 0))` fois sur `r sum(!is.na(Veh$ClaimAmount))`. Cela revient à dire qu'un assuré ne fera pas de réclamation `r round(sum(na.omit(Veh$ClaimAmount == 0))/sum(!is.na(Veh$ClaimAmount)), 3)*100`% du temps. 

\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|c| } 
 \hline
 Moyenne & Médiane & Écart-type & Minimum & Maximum \\ 
 \hline
 `r mean(na.omit(Veh$ClaimAmount))` & `r median(na.omit(Veh$ClaimAmount))` & `r sd(na.omit(Veh$ClaimAmount))` & `r min(na.omit(Veh$ClaimAmount))` & `r max(na.omit(Veh$ClaimAmount))` \\ 
 \hline
\end{tabular}
\end{center}

Puisqu'un montant de réclamation peut prendre des valeurs assez élevées, les graphiques peuvent devenir plutôt difficiles à lire. Pour remédier à ce problème, le logarithme du montant total des réclamations est utilisé dans les graphiques. Cela a cependant un coût : toutes les réclamations de 0 doivent être retirées du jeu de données. Des informations supplémentaires par rapport à ces réclamations seront ajoutées au long de l'analyse exploratoire pour pallier ce défaut.


```{r HistClaim, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:HistRecl}Histogramme du logarithme des montants de réclamation"}

ggplot(VehClaimOnly, aes(x=LogClaim))+
  geom_histogram()

```

Comme on peut voir dans la Figure \ref{fig:HistRecl}, il

\clearpage

## Exposition

\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|c| } 
 \hline
 Moyenne & Médiane & Écart-type & Minimum & Maximum \\ 
 \hline
 `r mean(Veh$ExposTotal)` & `r median(Veh$ExposTotal)` & `r sd(Veh$ExposTotal)` & `r min(Veh$ExposTotal)` & `r max(Veh$ExposTotal)` \\ 
 \hline
\end{tabular}
\end{center}

```{r PointsExposition, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointExpos}Logarithme des réclamations en fonction de l'exposition"}

ggplot(VehClaimOnly, aes(x=ExposTotal, y=LogClaim)) + 
  geom_point(alpha = 0.3) +
  ylab("Logarithme des réclamations")

```

\clearpage 

## Genre

La variable **Gender** a quatre niveaux : *Male*, *Female*, *Corporate* et *NA*.

\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
 \hline
  & Male & Female & Corporate & NA \\ 
 \hline
 Fréquence & `r sum(na.omit(Veh$Gender) == "Male")` & `r sum(na.omit(Veh$Gender) == "Female")` & `r sum(na.omit(Veh$Gender) == "Corporate")` & `r sum(is.na(Veh$Gender))` \\ 
 \hline
\end{tabular}
\end{center}

Lorsqu'on regarde la quantité de ces personnes qui n'ont pas fait de réclamation, on remarque qu'il n'y a absolument aucune réclamation pour le genre *Corporate* et que *NA* semble avoir la plus petite proportion de personnes n'ayant fait aucune réclamation.

\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
 \hline
  & Male & Female & Corporate & NA \\ 
 \hline
 Aucune réclamation & `r sum(na.omit(Veh$ClaimAmount[Veh$Gender == "Male"] == 0))` & `r sum(na.omit(Veh$ClaimAmount[Veh$Gender == "Female"]) == 0)` & `r sum(na.omit(Veh$ClaimAmount[Veh$Gender == "Corporate"]) == 0)` & `r sum(na.omit(Veh$ClaimAmount[is.na(Veh$Gender)] == 0))` \\ 
 \hline
\end{tabular}
\end{center}

En terme de sévérité, les moyennes des réclamations ne semblent pas changer d'un genre à un autre, mais il est possible d'observer un peu plus de réclamations extrêmes lorsque le genre est inconnu.


```{r BoxplotGender, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BoxPlotGender}Logarithme des réclamations par genre"}

ggplot(VehClaimOnly, aes(x=Gender, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations")

```

\clearpage 

## Âge du conducteur

```{r BoxplotAge, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BoxPlotDrivAge}Logarithme des réclamations par Âge de conducteur"}

ggplot(VehClaimOnly, aes(x=DrivAge, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations")

```

\clearpage 

## Année du véhicule

```{r PointsAgeVeh, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointVehYear}Logarithme des réclamations en fonction de l'année du véhicule"}

ggplot(VehClaimOnly, aes(x=VehYear, y=LogClaim)) + 
  geom_point(alpha = 0.3) +
  ylab("Logarithme des réclamations") +
  geom_smooth()

```


\clearpage 

## Modèle du véhicule

```{r, message=FALSE, echo = FALSE, warning = FALSE}

VehManufGraph <- VehClaimOnly$VehManuf
lvl2 <- levels(VehClaimOnly$VehManuf)
lvl2[which(table(VehClaimOnly$VehManuf) < 500)] <- "Other"
levels(VehManufGraph) <- lvl2

```


```{r BoxplotManuf, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BoxPlotArea}Logarithme des réclamations par région"}

ggplot(VehClaimOnly, aes(x=VehManufGraph, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations") +
  coord_flip()

```


\clearpage 

## Area

```{r ModifArea, message=FALSE, echo = FALSE, warning = FALSE}

AreaGraph <- VehClaimOnly$Area
lvl3 <- levels(VehClaimOnly$Area)
lvl3[which(table(VehClaimOnly$Area) < 2000)] <- "Other"
levels(AreaGraph) <- lvl3

```

```{r BoxplotArea, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BoxPlotArea}Logarithme des réclamations par région"}

ggplot(VehClaimOnly, aes(x=AreaGraph, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations") +
  coord_flip()

```

\clearpage

## State

```{r ModifState, message=FALSE, echo = FALSE, warning = FALSE}

StateGraph <- VehClaimOnly$State
lvl4 <- levels(VehClaimOnly$State)
lvl4[which(table(VehClaimOnly$State) < 2000)] <- "Other"
levels(StateGraph) <- lvl4

```

```{r BoxplotState, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:BoxPlotState}Logarithme des réclamations par état"}

ggplot(VehClaimOnly, aes(x=StateGraph, y=LogClaim)) + 
  geom_boxplot() +
  ylab("Logarithme des réclamations") +
  coord_flip()

```

\clearpage


## Prime Totale

La prime totale est une variable qui reflète la somme totale de primes pour une combinaison véhicule-assuré donnée. Afin de mieux comprendre la distribution de cette variable, plusieurs analyses peuvent être effectuées:

```{r PointsPrimeHist, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointPremHist}Logarithme des réclamations en fonction de la prime totale"}

ggplot(VehClaimOnly, aes(x=log(PremTotal)))+
    geom_histogram()

```

La distribution des primes totales présente une asymétrie négative, avec un nombre plus important de primes de faible montant par rapport à celles de montant élevé.

```{r PointsPrime, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointPrem}Logarithme des réclamations en fonction de la prime totale"}

ggplot(VehClaimOnly, aes(x=log(PremTotal), y=LogClaim)) + 
  geom_point(alpha = 0.3) +
  ylab("Logarithme des réclamations")

```
la prime totale présente clairement la meilleure puissance prédictive, mais elle ne peut être utilisée pour le modèle, car le but d'un modèle de prime pure est de la prédire. Cependant, on remarque que les primes plus basses sont associées à une plus grande variance dans les montants de réclamations. En conséquence, notre modèle devrait être plus performant pour prédire les réclamations des gros risques, c'est à dire, ceux qui ont une grande mesure d'exposition et des dimensions risquées.

\clearpage

## SumInsAvg

Cette variable correspond au montant moyen assuré aggrégé au grain de la table, et représente la limite supérieure des réclamations possibles. On peut explorer cet hypothèse avec le graphique suivant:

```{r PreuveIns, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointSumInsAvg}Logarithme des réclamations en fonction de SumInsAvg"}
library(gridExtra)

ggplot(VehClaimOnly,aes(x=ClaimAmount/ClaimNb, y=SumInsAvg, col = ClaimAmount/ClaimNb < SumInsAvg))+
    geom_point(alpha=0.4)+
    stat_function(fun=function(x) x)

```

On voit donc que dans la très grande majorité des cas, le montant assuré moyen est supérieure au montant réclamé par réclamation. On peut croire que les points sous la courbe représente des observations où le montant a assuré diminué au cours de la période assuré. En effet, Si le montant assuré a été plus élevé à un moment et a diminué subitement, il est possible que la mesure de sévérité moyenne soit plus élevé que le montant d'assurance moyen.


```{r PointsInsAvg, message=FALSE, echo = FALSE, warning = FALSE, fig.cap="\\label{fig:PointSumInsAvg}Logarithme des réclamations en fonction de SumInsAvg"}

ggplot(VehClaimOnly, aes(x=SumInsAvg, y=LogClaim)) + 
  geom_point(alpha = 0.3) +
  ylab("Logarithme des réclamations")+
    geom_smooth()
```



\clearpage

# Traitement des valeurs manquantes

## Visualisation

```{r MissingDataVis, message=FALSE, echo=FALSE, warning=FALSE, results='hide', fig.keep='all', fig.cap="\\label{fig:MissingDataVis}Visualisation des données manquantes"}

md.pattern(Veh, rotate.names = T)
```

On remarque que lorsque la variable «Area» est inconnue, la variable «State» l'est aussi. Puisqu'il y a  seulement `r sum(is.na(Veh$Area) & is.na(Veh$State))` observations manquantes pour ces deux variables et que lorsque ces variable sont absentes aucune autre variable l'est, nous les retirons du jeu de données.

```{r, message=FALSE, echo=FALSE}
Veh <- Veh[!is.na(Veh$Area) & !is.na(Veh$State),]
```


De plus, lorsque «VehModel» est manquante, «VehGroup» l'est également. Cela est tout à fait intuitif, car il n'est pas possible de classifier un véhicule si son modèle n'est pas connu. On test l'hypothèse que la variable «VehModel» est MCAR.

```{r, message=FALSE}
manq <- is.na(Veh$VehModel)
chisq.test(Veh$Gender, manq, correct = F)
chisq.test(Veh$DrivAge, manq, correct = F)
chisq.test(Veh$State, manq, correct = F)
chisq.test(Veh$VehYear, manq, correct = F)
```
Toutes les *p-values* approchent de 0, on rejette l'hypothèse nulle. Le patron de non-réponse de la variable «VehModel» n'est pas MCAR. Cette conclusion est identique pour la variable «VehGroup».

En effectuant des tests du khi-carré de Pearson, il est apparent que la variable «VehManuf» n'est pas MCAR. Toutes les *p-values* sont confortablement plus petites que 0,05.

```{r, message=FALSE, echo=FALSE}
manq <- is.na(Veh$VehManuf)
chisq.test(Veh$Gender, manq, correct = F)
chisq.test(Veh$DrivAge, manq, correct = F)
chisq.test(Veh$State, manq, correct = F)
chisq.test(Veh$VehYear, manq, correct = F)
```


La variable «DrivAge» est la plus absente du jeu de données; elle est manquante dans `r round(sum(is.na(Veh$DrivAge)) / nrow(Veh) * 100, 2)`% des observations. Faisons un diagramme boxplot pour voir s'il y a un lien entre la présence d'une observation manquante pour cette variable et le montant des réclamations.

```{r, DrivAgelinkwithClaims, message=FALSE, echo=FALSE, warning=FALSE, results='hide', fig.keep='all', fig.cap="\\label{fig:DrivAgelinkwithClaims}Lien entre le patron de non-réponse de la variable «DrivAge» et le logarithme des réclamations"}
manq <- is.na(VehClaimOnly$DrivAge)
ggplot(VehClaimOnly, aes(x = manq, y = log(ClaimAmount))) +
  geom_boxplot() +
  ylab("Logarithme des réclamations") +
  xlab("Patron de non-réponse de «DrivAge»")
```
Il semble peu probable que les données manquantes de «DrivAge» soient MCAR. Effectivement, les tests du khi-carré de Pearson rejettent l'hyopthèse nulle que le Patron de non-réponse de cette variable est MCAR. Il ne sera pas possible d'utiliser l'approche des cas complets, donc une méthode d'imputation stochastique sera privilégié. Puisqu'il n'y a pas de test pour savoir si les données manquantes sont MAR ou NMAR, il est possible qu'un biais reste présent dans les données après l'imputation.
```{r, message=FALSE, echo=FALSE}
manq <- is.na(Veh$DrivAge)
chisq.test(Veh$Gender, manq, correct = F)
chisq.test(Veh$VehManuf, manq, correct = F)
chisq.test(Veh$State, manq, correct = F)
chisq.test(Veh$Area, manq, correct = F)
chisq.test(Veh$ClaimAmount, manq, correct = F)
```

Dans SumInsAvg remplacer les 0 par NA et traiter.

\clearpage

# Conclusion
